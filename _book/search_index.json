[["multiple-populations.html", "Chapter 7 Multiple populations", " Chapter 7 Multiple populations In some situations, the diagnostic tests will be applied in two or more populations with different disease prevalence. In such cases, it could be reasonable to assume that: The prevalence varies from one population to another The tests Se and Sp are constant from one population to another It could then be advantageous to model the different populations simultaneously in a same LCM as described by Hui and Walter (1980). With two populations, we would have six unknown parameters (SeA and SpA, SeB and SpB, and each population’s prevalence, P1 and P2). When conducting two diagnostic tests in two populations, the data generated can be presented as two 2x2 tables presenting the cross-classified results of the two tests. Table. Cross-classified results from two diagnostic tests in two populations. Population 1 Population 2 Test A+ Test A- Test A+ Test A- Test B+ Pop1 n1 Pop1 n3 Test B+ Pop2 n1 Pop2 n3 Test B- Pop1 n2 Pop1 n4 Test B- Pop2 n2 Pop2 n4 We can see from these 2x2 tables that we have 6 degrees of freedom available. Indeed, in each of the 2x2 table, we have three cells that do contribute a valuable information and the information in the 4th cell can be “guessed” using the total number of observations minus the content of the other three cells. The model proposed by Hui and Walter (1980) is, therefore, barely identifiable. Cheung et al. (2021) have described how the number of unknown parameters and the degrees of freedom vary as function of the number of population studied when comparing two conditionally independent diagnostic tests (see below). Table. Number of degrees of freedom and of unknown parameters when comparing two conditionally independent diagnostic tests across various number of populations (adapted from Cheung et al. (2021)). Number of Populations Number of unknown parameters (np) Number of degrees of freedom (df) Minimum number of informative priors needed 1 5 3 2 2 6 6 0 3 7 9 0 4 8 12 0 p 4+p 3*p if df &lt; np, then np-df The likelihood function that could be used to link the observed data (Pop1 n1, Pop1 n2, …, Pop2 n4) to the unknown parameters (SeA and SpA, SeB and SpB, and P1 and P2) can be described as follows: \\(Ppop1[1:4] \\sim dmulti(Pop1[1:4], nPop1)\\) \\(Ppop1_1 = P1*SeA*SeB + (1-P1)*(1-SpA)*(1-SpB)\\) \\(Ppop1_2 = P1*SeA*(1-SeB) + (1-P1)*(1-SpA)*SpB\\) \\(Ppop1_3 = P1*(1-SeA)*SeB + (1-P1)*SpA*(1-SpB)\\) \\(Ppop1_4 = P1*(1-SeA)*(1-SeB) + (1-P1)*SpA*SpB\\) \\(Ppop2[1:4] \\sim dmulti(Pop2[1:4], nPop2)\\) \\(Ppop2_1 = P2*SeA*SeB + (1-P2)*(1-SpA)*(1-SpB)\\) \\(Ppop2_2 = P2*SeA*(1-SeB) + (1-P2)*(1-SpA)*SpB\\) \\(Ppop2_3 = P2*(1-SeA)*SeB + (1-P2)*SpA*(1-SpB)\\) \\(Ppop2_4 = P2*(1-SeA)*(1-SeB) + (1-P2)*SpA*SpB\\) Where \\(Pop1_1\\) to \\(Pop1_4\\) and \\(Pop2_1\\) to \\(Pop2_4\\) are the probabilities of falling in a given cell of the 2x2 table in population 1 and population 2, respectively; and \\(nPop1\\) and \\(nPop2\\) are the number of individuals tested in population 1 and 2, respectively. Thus, if you look carefully, we simply duplicated the likelihood function used before and we added subscripts to differentiate the cells, probabilities, and disease prevalence of the two populations. Cool hey? If you have three, four, etc populations, you can then extend the likelihood function to include them. With three or more populations, the model is not just barely identifiable anymore, it becomes fully identifiable. To run such a model, we simply need to provide, for each population, a dataset where n1, n2, n3, and n4 are listed (in that order). For instance, if we use herd #1 and herd #2 from the PAG vs. US study, we have the following 2x2 tables: Table. Cross-classified results from the PAG and US diagnostic tests in herd #1 and herd #2. Herd 1 Total Herd 2 Total US+ US- US+ US- PAG+ 138 10 PAG+ 71 8 PAG- 139 123 PAG- 0 69 Total 262 Total 148 The dataset could, thus be created as follows: #n is of the form : (TestA pos and TestB pos), (TestA pos and TestB neg), (TestA neg and TestB pos), then (TestA neg and TestB neg) datalist &lt;- list(Pop1=c(138,1,10,113), Pop2=c(71, 0, 8, 69) ) We could provide the values that will be used to described the prior distributions as we did before. The only difference is that we now have two prevalence parameters (P1 and P2) to describe. In the example below, I will use vague priors for all parameters (just because we can!). #We could first create labels for TestA and TestB TestA &lt;- &quot;US&quot; TestB &lt;- &quot;PAG&quot; #Provide information for the prior distributions (all beta distributions) for the 6 unknown parameters Prev1.shapea &lt;- 1 #a shape parameter for Prev in population 1 Prev1.shapeb &lt;- 1 #b shape parameter for Prev in population 1 Prev2.shapea &lt;- 1 #a shape parameter for Prev in population 2 Prev2.shapeb &lt;- 1 #b shape parameter for Prev in population 2 Se.TestA.shapea &lt;- 1 #a shape parameter for Se of TestA Se.TestA.shapeb &lt;- 1 #b shape parameter for Se of TestA Sp.TestA.shapea &lt;- 1 #a shape parameter for Sp of TestA Sp.TestA.shapeb &lt;- 1 #b shape parameter for Sp of TestA Se.TestB.shapea &lt;- 1 #a shape parameter for Se of TestB Se.TestB.shapeb &lt;- 1 #b shape parameter for Se of TestB Sp.TestB.shapea &lt;- 1 #a shape parameter for Sp of TestB Sp.TestB.shapeb &lt;- 1 #b shape parameter for Sp of TestB #I will also need the total number of individuals tested in each population (nPop1 and nPop2) n &lt;- sapply(datalist, sum) nPop1 &lt;- n[1] nPop2 &lt;- n[2] With that, we have everything that is needed to write the JAGS model. #Create the JAGS text file model_2tests_2pop_indep &lt;- paste0(&quot;model{ #=== LIKELIHOOD ===# #=== POPULATION 1 ===# Pop1[1:4] ~ dmulti(p1[1:4], &quot;,nPop1,&quot;) p1[1] &lt;- Prev1*Se_&quot;, TestA, &quot;*Se_&quot;, TestB, &quot; + (1-Prev1)*(1-Sp_&quot;, TestA, &quot;)*(1-Sp_&quot;, TestB, &quot;) p1[2] &lt;- Prev1*Se_&quot;, TestA, &quot;*(1-Se_&quot;, TestB, &quot;) + (1-Prev1)*(1-Sp_&quot;, TestA, &quot;)*Sp_&quot;, TestB, &quot; p1[3] &lt;- Prev1*(1-Se_&quot;, TestA, &quot;)*Se_&quot;, TestB, &quot; + (1-Prev1)*Sp_&quot;, TestA, &quot;*(1-Sp_&quot;, TestB, &quot;) p1[4] &lt;- Prev1*(1-Se_&quot;, TestA, &quot;)*(1-Se_&quot;, TestB, &quot;) + (1-Prev1)*Sp_&quot;, TestA, &quot;*Sp_&quot;, TestB, &quot; #=== POPULATION 2 ===# Pop2[1:4] ~ dmulti(p2[1:4], &quot;,nPop2,&quot;) p2[1] &lt;- Prev2*Se_&quot;, TestA, &quot;*Se_&quot;, TestB, &quot; + (1-Prev2)*(1-Sp_&quot;, TestA, &quot;)*(1-Sp_&quot;, TestB, &quot;) p2[2] &lt;- Prev2*Se_&quot;, TestA, &quot;*(1-Se_&quot;, TestB, &quot;) + (1-Prev2)*(1-Sp_&quot;, TestA, &quot;)*Sp_&quot;, TestB, &quot; p2[3] &lt;- Prev2*(1-Se_&quot;, TestA, &quot;)*Se_&quot;, TestB, &quot; + (1-Prev2)*Sp_&quot;, TestA, &quot;*(1-Sp_&quot;, TestB, &quot;) p2[4] &lt;- Prev2*(1-Se_&quot;, TestA, &quot;)*(1-Se_&quot;, TestB, &quot;) + (1-Prev2)*Sp_&quot;, TestA, &quot;*Sp_&quot;, TestB, &quot; #=== PRIOR ===# Prev1 ~ dbeta(&quot;,Prev1.shapea,&quot;, &quot;,Prev1.shapeb,&quot;) ## Prior for Prevalence in population 1 Prev2 ~ dbeta(&quot;,Prev2.shapea,&quot;, &quot;,Prev2.shapeb,&quot;) ## Prior for Prevalence in population 2 Se_&quot;, TestA, &quot; ~ dbeta(&quot;,Se.TestA.shapea,&quot;, &quot;,Se.TestA.shapeb,&quot;) ## Prior for Se of Test A Sp_&quot;, TestA, &quot; ~ dbeta(&quot;,Sp.TestA.shapea,&quot;, &quot;,Sp.TestA.shapeb,&quot;) ## Prior for Sp of Test A Se_&quot;, TestB, &quot; ~ dbeta(&quot;,Se.TestB.shapea,&quot;, &quot;,Se.TestB.shapeb,&quot;) ## Prior for Se of Test B Sp_&quot;, TestB, &quot; ~ dbeta(&quot;,Sp.TestB.shapea,&quot;, &quot;,Sp.TestB.shapeb,&quot;) ## Prior for Sp of Test B }&quot;) #write as a text (.txt) file write.table(model_2tests_2pop_indep, file=&quot;model_2tests_2pop_indep.txt&quot;, quote=FALSE, sep=&quot;&quot;, row.names=FALSE, col.names=FALSE) With this code, you could, again, simply modify the labels for Test A and Test B, and the shape parameters for the prior distributions and the text file with the JAGS model will automatically be updated. Currently, it looks like this: Text file with the model for 2 independent diagnostic tests applied to two populations. Again, we will need to provide a list of initial values (one per Markov chain) for all unknown parameters. Careful again, we now have two prevalence (Prev1 and Prev2). #Initializing values for the parameters Prev, and the Ses and Sps of the two tests for the 3 chains. inits &lt;- list(list(Prev1=0.50, Prev2=0.50, Se_US=0.90, Sp_US=0.90, Se_PAG=0.90, Sp_PAG=0.90), list(Prev1=0.60, Prev2=0.60, Se_US=0.80, Sp_US=0.80, Se_PAG=0.80, Sp_PAG=0.80), list(Prev1=0.40, Prev2=0.40, Se_US=0.70, Sp_US=0.70, Se_PAG=0.70, Sp_PAG=0.70) ) We can run the model using jags() function as seen before. library(R2jags) library(coda) #Run the Bayesian model bug.out &lt;- jags(data=datalist, model.file=&quot;model_2tests_2pop_indep.txt&quot;, parameters.to.save=c(&quot;Prev1&quot;, &quot;Prev2&quot;, &quot;Se_US&quot;, &quot;Sp_US&quot;, &quot;Se_PAG&quot;, &quot;Sp_PAG&quot;), n.chains=3, inits=inits, n.iter=11000, n.burnin=1000, n.thin=1, DIC=FALSE) ## Compiling model graph ## Resolving undeclared variables ## Allocating nodes ## Graph information: ## Observed stochastic nodes: 2 ## Unobserved stochastic nodes: 6 ## Total graph size: 43 ## ## Initializing model Then we could produce the diagnostic plots, compute the ESS, and print out our results as we did previously (results not shown). library(mcmcplots) bug.mcmc &lt;- as.mcmc(bug.out) mcmcplot(bug.mcmc, title=&quot;Diagnostic plots&quot;) effectiveSize(bug.mcmc) print(bug.out, digits.summary=3) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
